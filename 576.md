  ```
  class Solution {
public:
    int findPaths(int m, int n, int N, int i, int j) {
    	if (mp.find({ i,j,N }) != mp.end())return mp[{i, j, N}];
    	if (N <= 0)return 0;
    	long long count = 0;
    	if (i - 1 >= 0) {
    		long long tmp = findPaths(m, n, N - 1, i - 1, j);
    		count += tmp;
    	}
    	else {
    		count = (count + 1);
    	}
    	if (i + 1 < m) {
    		long long tmp = findPaths(m, n, N - 1, i + 1, j);
    		count += tmp;
    	}
    	else {
    		count = (count + 1);
    	}
    	if (j - 1 >= 0) {
    		long long tmp = findPaths(m, n, N - 1, i, j - 1);
    		count += tmp;
    	}
    	else {
    		count = (count + 1);
    	}
    	if (j + 1 < n) {
    		long long tmp = findPaths(m, n, N - 1, i, j + 1);
    		count += tmp;
    	}
    	else {
    		count = (count + 1);
    	}
    	count %= (Pow(10, 9) + 7);
    	mp[{i, j, N}] = count;
    	return count;
    }
private:
    long long Pow(int a, int b) {
    	long long result = 1;
    	while (b--) {
    		result *= a;
    	}
    	return result;
    }
    map<vector<int>,long long> mp;
};
```
<pre>暴力递归。然后用一个map将对应的{i,j,N}的值存储起来。</pre>
